#!/usr/bin/env python3
# challenges, and more
import yaml, argparse, random, wonderwords, datetime, string 
from time import sleep
from dateutil.relativedelta import relativedelta
from pathlib import Path
def translate(word, side = "lern") -> str:
    if side == "lern":
        return ''.join(lern.get(ch,ch) for ch in word)
    if side == "normal":
        for key, value in normdub.items():
            word = word.replace(key, value)
        return ''.join(normsing.get(ch,ch) for ch in word)
def qchoice() -> None:
    wor = w.word()
    print(f"{translate(wor)} means")
    wors = w.random_words(4, word_min_length=len(wor), word_max_length=len(wor))
    wors[random.randint(0,3)] = wor
    wo = [f"{wors.index(wo)+1} {wo}" for wo in wors] 
    print('\n'.join(wo))
    try:
        ans = input("Which one: ")
    except KeyboardInterrupt:
        exit()
    anin = True
    try:
        ans = int(ans)
    except:
        anin = False
    if ans == wor:
        print("Great")
    elif anin and wor == wors[ans-1]:
        print("Great")
    else:
        print(f"Correct answer is {wor}")
        raise ValueError("Braille or you'll stay blank")
def qchoicehard() -> None:
    wor = w.word()
    print(f"{translate(wor)} means")
    try:
        ans = input("")
    except KeyboardInterrupt:
        exit()
    if ans == wor:
        print("Great")
    else:
        print(f"Correct answer is {wor}")
        raise ValueError("Braille or you'll stay blank")
def qrevchoice() -> None:
    wor = w.word()
    print(f"{wor} means")
    wors = w.random_words(4, word_min_length=len(wor), word_max_length=len(wor))
    wors = [translate(asd) for asd in wors]
    wors[random.randint(0,3)] = translate(wor)
    wo = [f"{wors.index(wo)+1} {wo}" for wo in wors] 
    print('\n'.join(wo))
    alpha(True)
    try:
        ans = input("Which one: ")
    except KeyboardInterrupt:
        exit()
    anin = True
    try:
        ans = int(ans)
    except:
        anin = False
    if ans == translate(wor):
        print("Great")
    elif anin and translate(wor) == wors[ans-1]:
        print("Great")
    else:
        print(f"Correct answer is {translate(wor)}")
        raise ValueError("Braille or you'll stay blank")
def qrevchoicehard() -> None:
    wor = w.word()
    print(f"{wor} means")
    alpha(True)
    try:
        ans = input("")
    except KeyboardInterrupt:
        exit()
    if ans == translate(wor):
        print("Great")
    else:
        print(f"Correct answer is {translate(wor)}")
        raise ValueError("Braille or you'll stay blank")
def qchar() -> None:
    le = random.choice(string.ascii_lowercase)
    print(f"{translate(le)} is")
    les = [random.choice(string.ascii_lowercase) for i in range(4)]
    les[random.randint(0,3)] = le
    woles = [f"{les.index(lo)+1} {lo}" for lo in les]
    print('\n'.join(woles))
    try:
        ans = input("Which one: ").lower()
    except KeyboardInterrupt:
        exit()
    anin = True
    try:
        ans = int(ans)
    except:
        anin = False
    if ans == le:
        print("Great")
    elif anin and le == les[ans-1]:
        print("Great")
    else:
        print(f"Correct asnwer is {le}")
        raise ValueError("Braille or you'll stay blank")
def qcharhard() -> None:
    le = random.choice(string.ascii_lowercase)
    print(f"{translate(le)} is")
    try:
        ans = input("").lower()
    except KeyboardInterrupt:
        exit()
    if ans == le:
        print("Great")
    else:
        print(f"Correct asnwer is {le}")
        raise ValueError("Braille or you'll stay blank")
def qrevchar() -> None:
    le = random.choice(string.ascii_lowercase)
    print(f"{le} is")
    les = [random.choice(string.ascii_lowercase) for i in range(4)]
    les = [translate(asd) for asd in les]
    les[random.randint(0,3)] = translate(le)
    woles = [f"{les.index(lo)+1} {lo}" for lo in les]
    print('\n'.join(woles))
    alpha(True)
    try:
        ans = input("Which one: ").lower()
    except KeyboardInterrupt:
        exit()
    anin = True
    try:
        ans = int(ans)
    except:
        anin = False
    if ans == translate(le):
        print("Great")
    elif anin and translate(le) == les[ans-1]:
        print("Great")
    else:
        print(f"Correct asnwer is {translate(le)}")
        raise ValueError("Braille or you'll stay blank")
def qrevcharhard() -> None:
    le = random.choice(string.ascii_lowercase)
    print(f"{le} is")
    alpha(True)
    try:
        ans = input("").lower()
    except KeyboardInterrupt:
        exit()
    if ans == translate(le):
        print("Great")
    else:
        print(f"Correct asnwer is {translate(le)}")
        raise ValueError("Braille or you'll stay blank")
def menu() -> None:
    global fire
    print(f"\033c{logo}")
    fire = "\033[90m󰈸\033[0m"
    if not first:
        streakf(check = True)
    livs()
    print(f"Your current streak: {streak} {fire}")
    print(f"Lvl: {lvl} exp: {exp}")
    gbhyjmkn = ["\033[91m🫀\033[0m" for i in range(lives)]
    print(f"Lifes: {''.join(gbhyjmkn)}")
    options = ["Play", "Options", "Exit"]
    opts = [f"{options.index(op)+1} {op}" for op in options]
    loop = True
    while loop:
        print("\n".join(opts))
        try:
            opt = input("Which to play: ").lower()
        except KeyboardInterrupt:
            exit()
        if opt in ["play", "p", "1"]:
            play()
        if opt in ["options", "o", "2"]:
            option()
        if opt in ["exit", "e", ":q", "3"]:
            exit()
def option() -> None:
    global hard
    print("\033cOptions")
    options = ["reset strek","check lifes","Show alphabet", "set lesson length", "Hard Mode","Back"]
    opts = [f"{options.index(i)+1} {i}" for i in options]
    print('\n'.join(opts))
    loop = True
    while loop:
        try:
            ans = input("Which one: ").lower()
        except KeyboardInterrupt:
            exit()
        if ans in ["reset streak", "1"]:
            streakf(True)
        if ans in ["check lifes", "2"]:
            livs(ver=True)
        if ans in ["show alphabet", "3", "show", "alpha"]:
            alpha()
        if ans in ["set lesson length", "4", "len", "set len"]:
            sll()
        if ans in ["hard mode", "5", "hard", "hardmode"]:
            if not conf["hard"]:
                hard = True
                conf.update({"hard": True})
            else:
                hard = False
                conf.update({"hard": False})
            with open(path, "w") as f:
                yaml.dump(conf,f,sort_keys=False,allow_unicode=True)
        if ans in ["back", "6", ":q"]:
            loop = False
            menu()
def sll() -> None:
    global lessonLength
    print(f"Current lesson length {lessonLength}")
    try:
        val = int(input("Set length(length >= 5): "))
        if val < 5:
            raise ValueError()
        loop = False
    except ValueError:
        loop = True
    while loop:
        try:
            val = int(input("Length need to be a number >=5: "))
            if val < 5:
                raise ValueError()
            loop = False
        except ValueError:
            loop = True
    lessonLength = val
    conf.update({"length": val})
    with open(path, "w") as f:
        yaml.dump(conf,f,allow_unicode=True,sort_keys=False)
def play() -> None:
    global lives, ldat
    playmodes = ["char", "revchar", "choice", "revchoice"]
    if lives == 0:
        print("You don't have lifes")
    else:
        for i in range(lessonLength):
            if lives > 0:
                livs()
                try:
                    play = random.choice(playmodes)
                    print(f"Exercise {i+1}/{lessonLength}")
                    if play == "char":
                        if not hard:
                            qchar()
                            exppl(lvl+streak+5)
                        else:
                            qcharhard()
                            exppl((lvl+streak+5)*2)
                    elif play == "choice":
                        if not hard:
                            qchoice()
                            exppl(lvl+streak+10)
                        else:
                            qchoicehard()
                            exppl((lvl+streak+10)*2)
                    if play == "revchar":
                        if not hard:
                            qrevchar()
                            exppl(lvl+streak+10)
                        else:
                            qrevcharhard()
                            exppl((lvl+streak+15)*2)
                    elif play == "revchoice":
                        if not hard:
                            qrevchoice()
                            exppl(lvl+streak+15)
                        else:
                            qrevchoicehard()
                            exppl((lvl+streak+20)*2)
                except ValueError:
                    lives -= 1
                    if lives+1 == maxlive:
                        ldat = ftime + datetime.timedelta(minutes=30) 
                        conf.update({"lives": lives, "ldat": ldat})
                    else:
                        conf.update({"lives": lives})
                    with open(path, "w") as f:
                        yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
            else:
                print("Your lifes are gone")
                print(f"You lose on lesson {i+1}/{lessonLength}")
                break
        if lives > 0:
            if not hard:
                print("Congrats you compleat a lesson")
            else:
                print("Congrats you compleat hard lesson")
            streakf()
def streakf(rest: bool = False, check: bool = False) -> None:
    global streak, fire
    up = False
    if check:
        if sdata < time:
            print(smem)
            print("I'm at your door now")
            conf.update({"streak": {"count": 0, "data": time}})
            streak = 0
            up = True 
        elif sdata == time:
            fire = "\033[90m󰈸\033[0m"
        elif sdata > time:
            fire = "\033[93m󰈸\033[0m"
    else:
        if rest:
            print("Streak reset")
            conf.update({"streak": {"count": 0, "data": (time - relativedelta(days=1)).strftime("%Y.%m.%d")}})
            streak = 0
            up = True
        else:
            nex = sdata + relativedelta(days=1)
            if sdata <= ftime:
                conf.update({"streak": {"count": streak+1, "data": (time + relativedelta(days=1)).strftime("%Y.%m.%d") }})
                streak += 1
                up = True
                print(f"Your streak raise: {streak}")
    if up:
        with open(path, "w") as f:
            yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
def livs(ver: bool = False) -> None:
    global lives, ldat
    if lives != maxlive and ftime > ldat:
        lives += 1
        ldat = ldat + datetime.timedelta(minutes=30)
        if lives == maxlive:
            conf.update({"lives": lives, "ldat": None})
        else:
            conf.update({"lives": lives, "ldat": ldat})
            livs()
        with open(path, "w") as f:
            yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
    elif lives != maxlive and ver:
        print(f"Next lifes come {ldat.strftime('%Y.%m.%d %H:%M:%S')}")
        print(f"You have {lives} lifes")
    elif lives == maxlive and ver:
        print("You have maximum amount of lifes")
        print(f"You have {lives} lifes")
def exppl(count: int = None) -> None:
    global exp, lvl
    if count != None:
        exp += count
        if exp >= ((lvl+1)*4)**(lvl+3):
            lvl += 1
            print(f"Lvl up {lvl}")
        conf.update({"exp": exp, "lvl": lvl})
        with open(path, "w") as f:
            yaml.dump(conf, f, allow_unicode=True, sort_keys=False)
def alpha(key: bool = False) -> None:
    end = ""
    if not key:
        for key, value in lern.items():
            end = end + f"{key}:{value} "
    else:
        sus = []
        values = []
        for key, value in lern.items():
            values.append(value)
        random.shuffle(values)
        values = [f"\033[47m\033[30m{value}\033[0m|" for value in values]
        vals = [''.join(values[i:i+10]) for i in range(0,len(values)+1,10)]
        end = '\n'.join(vals)
    print(end)
def main(prof: str = None) -> None:
    global exp, time, logo, smem, path, ftime, w, streak, sdata, lives, lvl, ldat, maxlive, lessonLength, conf, first, lern, normsing, normdub, hard
    time = datetime.datetime.strptime(datetime.datetime.now().strftime("%Y.%m.%d"), "%Y.%m.%d")
    ftime = datetime.datetime.now()
    first = False
    if prof == None:
        path = f"{Path.home()}/.config/duo.yaml"
    else:
        path = f"{Path.home()}/.config/duo{prof}.yaml"
    try:
        with open(path, "r") as f:
            conf = yaml.load(f, Loader=yaml.FullLoader)
    except FileNotFoundError:
        print("Creating new profile")
        sleep(2)
        first = True
        with open(path, "w+") as f:
            conf = {"logo": "Welcome to duolingo for blind", "smem": "Your streak gone","streak": {"count": 0, "data": time.strftime("%Y.%m.%d")}, "lvl": 0, "exp": 0, "hard": False, "lives": 5, "maxlives": 5, "ldat": ftime, "length": 5}
            yaml.dump(conf, f, allow_unicode=True, sort_keys=False)
    try:
        logo = conf["logo"]
    except:
        logo = "Welcome to duolingo"
    try:
        smem = conf["smem"]
    except:
        smem = "Your streak gone"
    streak = conf["streak"]["count"]
    sdata = datetime.datetime.strptime(conf["streak"]["data"], "%Y.%m.%d")
    lvl = conf["lvl"]
    exp = conf["exp"]
    lives = conf["lives"]
    ldat = conf["ldat"]
    maxlive = conf["maxlives"]
    lessonLength = conf["length"]
    hard = conf["hard"]
    try:
        lern = conf["lern"]
    except:
        lern = {"a": "⠁","b": "⠃","c": "⠉","d": "⠙","e": "⠑","f": "⠋","g": "⠛","h": "⠓","i": "⠊","j": "⠚","k": "⠅","l": "⠇","m": "⠍","n": "⠝","o": "⠕","p": "⠏","q": "⠟","r": "⠗","s": "⠎","t": "⠞","u": "⠥","v": "⠧","w": "⠺","x": "⠭","y": "⠽","z": "⠵","ą":"⠡","ć":"⠩","ę":"⠱","ł":"⠣","ń":"⠹","ó":"⠬","ś":"⠪","ż":"⠯","ź":"⠮","0":"⠼⠚","1":"⠼⠁","2":"⠼⠃","3":"⠼⠉","4":"⠼⠙","5":"⠼⠑","6":"⠼⠋","7":"⠼⠛","8":"⠼⠓","9":"⠼⠊","-": "⠒",".": "⠲","'": "⡀",",": "⠂"}
    try:
        normsing = conf["normal"]["single"]

    except:
        normsing = {"⠁":"a","⠃":"b","⠉":"c","⠙":"d","⠑":"e","⠋":"f","⠛":"g","⠓":"h","⠊":"i","⠚":"j","⠅":"k","⠇":"l","⠍":"m","⠝":"n","⠕":"o","⠏":"p","⠟":"q","⠗":"r","⠎":"s","⠞":"t","⠥":"u","⠧":"v","⠺":"w","⠭":"x","⠽":"y","⠵":"z","⠡":"ą","⠩":"ć","⠱":"ę","⠣":"ł","⠹":"ń","⠬":"ó","⠪":"ś","⠯":"ż","⠮":"ź","-": "⠒",".":"⠲","'": "⡀",",":"⠂"}
    try:
        normdub = conf["normal"]["dubles"]
    except:
        normdub = {"⠼⠚": "0","⠼⠁": "1", "⠼⠃": "2","⠼⠉": "3","⠼⠙": "4","⠼⠑": "5","⠼⠋": "6","⠼⠛": "7","⠼⠓": "8","⠼⠊": "9"}
    w = wonderwords.RandomWord()
    menu()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-p", "--profile", help="set profile", nargs="*",default=None)
    args = parser.parse_args()
    if args.profile != None:
        args.profile = ' '.join(args.profile)
    main(args.profile)
