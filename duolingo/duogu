#!/usr/bin/env python3
import sys, os
import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import Gtk, Gdk, Adw
import yaml, argparse, random, wonderwords, datetime, string 
from playsound import playsound
from time import sleep
from dateutil.relativedelta import relativedelta
from pathlib import Path
dir_path = os.path.dirname(os.path.realpath(__file__))
os.chdir(dir_path)
css_provider = Gtk.CssProvider()
css_provider.load_from_path('style.css')
Gtk.StyleContext.add_provider_for_display(Gdk.Display.get_default(), css_provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
class MainWindow(Gtk.ApplicationWindow):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.set_size_request(808, 565)
        self.menu()
    def menu(self, *args, **kwargs):
        livs()
        self.mainbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.set_child(self.mainbox)
        self.tbox = Gtk.CenterBox(hexpand=True)
        self.mainbox.append(self.tbox)
        self.title = Gtk.Label(label=logo,wrap=True,justify='center')
        self.lives = Gtk.Label(label=f"{lives}ü´Ä")
        self.streak = Gtk.Label(label=f"{streak} Û∞à∏")
        self.lives.set_css_classes(["lifes"])
        self.tbox.set_start_widget(self.streak)
        if fire == 'gray':
            self.streak.set_css_classes(["nostreak","gstreak"])
        elif fire == 'orange':
            self.streak.set_css_classes(["streak","gstreak"])
        self.tbox.set_center_widget(self.title)
        self.tbox.set_end_widget(self.lives)
        self.lvlprog = Gtk.ProgressBar()
        self.lvlprog.set_show_text(False)
        self.lvlproc = Gtk.Label(label=f"{(exp/(((lvl+1)*4)*(lvl+3)))*100:.0f}%")
        self.lvlprog.set_fraction(exp/(((lvl+1)*4)*(lvl+3)))
        self.exppl(check=True)
        self.lvlbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, hexpand=True)
        self.mainbox.append(self.lvlbox)
        self.lvllebbox = Gtk.CenterBox()
        self.lvlbox.append(self.lvllebbox)
        self.lvlleb = Gtk.Label(label=f"{lvl} lvl")
        self.lvlpoinleb = Gtk.Label(label=f"{exp}/{((lvl+1)*4)*(lvl+3)}")
        self.lvllebbox.set_start_widget(self.lvlleb)
        self.lvllebbox.set_center_widget(self.lvlproc)
        self.lvllebbox.set_end_widget(self.lvlpoinleb)
        self.lvlbox.append(self.lvlprog)
        if lvlup:
            self.lvlleb.set_label(f"{lvl} lvl ü†ù")
            self.lvlleb.add_css_class("up")
        self.bbox = Gtk.Box(hexpand=True)
        self.mainbox.append(self.bbox)
        self.playbut = Gtk.Button(label="Play", hexpand=True)
        self.playbut.connect('clicked', self.initplay)
        self.options = Gtk.Button(label="Options", hexpand=True)
        self.options.connect('clicked', self.opt)
        self.exitb = Gtk.Button(label="Exit", hexpand=True)
        self.exitb.connect('clicked', self.exit)
        self.bbox.append(self.playbut)
        self.bbox.append(self.options)
        self.bbox.append(self.exitb)
        self.profbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL,hexpand=True,vexpand=True,valign=Gtk.Align.END,halign=Gtk.Align.END)
        self.mainbox.append(self.profbox)
        self.prof = Gtk.Button(label=profile)
        self.prof.connect('clicked', self.profmenu)
        self.profbox.append(self.prof)
    def setprog(self, *args, **kwargs):
        self.lvlprog.set_fraction(exp/(((lvl+1)*4)*(lvl+3)))
    def opt(self, *args, **kwargs):
        self.optbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL,vexpand=True)
        self.set_child(self.optbox)
        self.tbox = Gtk.CenterBox(hexpand=True)
        self.optbox.append(self.tbox)
        self.title = Gtk.Label(label="Options",wrap=True,justify='center')
        self.lives = Gtk.Label(label=f"{lives}ü´Ä")
        self.streak = Gtk.Label(label=f"{streak} Û∞à∏")
        self.lives.set_css_classes(["lifes"])
        self.tbox.set_start_widget(self.streak)
        if fire == 'gray':
            self.streak.set_css_classes(["nostreak","gstreak"])
        elif fire == 'orange':
            self.streak.set_css_classes(["streak","gstreak"])
        self.tbox.set_center_widget(self.title)
        self.tbox.set_end_widget(self.lives)
        self.opts = Gtk.Box(orientation=Gtk.Orientation.VERTICAL,hexpand=True)
        self.opts.set_css_classes(['optsbox'])
        self.optbox.append(self.opts)
        self.reststreak = Gtk.Button(label='Reset Streak',hexpand=True)
        self.reststreak.connect('clicked', streakf, True)
        self.showkeyboard = Gtk.Button(label='Show Keyboard',hexpand=True)
        self.showkeyboard.connect('clicked', self.showkeys, "optbox")
        self.setllen = Gtk.SpinButton()
        self.setllen.set_range(5,999)
        self.setllen.set_increments(1,1)
        self.setllen.connect("changed", self.ssl)
        self.hardmode = Gtk.Button(label="Hardmode")
        self.hardmode.connect('clicked', self.hmode)
        self.sound = Gtk.Button(label="Sounds")
        self.sound.connect('clicked', self.ssw)
        self.back = Gtk.Button(label='Back',hexpand=True)
        self.back.connect('clicked', self.menu)
        self.tttop = Gtk.Box()
        self.opts.append(self.tttop)
        self.bbbot = Gtk.Box()
        self.opts.append(self.bbbot)
        self.tttop.append(self.reststreak)
        self.tttop.append(self.showkeyboard)
        self.tttop.append(self.setllen)
        self.bbbot.append(self.hardmode)
        self.bbbot.append(self.sound)
        self.bbbot.append(self.back)
    def profmenu(self, *args, **kwargs):
        self.profbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL,vexpand=True)
        self.set_child(self.profbox)
        self.tbox = Gtk.CenterBox(hexpand=True)
        self.profbox.append(self.tbox)
        self.title = Gtk.Label(label="Profile",wrap=True,justify='center')
        self.lives = Gtk.Label(label=f"{lives}ü´Ä")
        self.streak = Gtk.Label(label=f"{streak} Û∞à∏")
        self.lives.set_css_classes(["lifes"])
        self.tbox.set_start_widget(self.streak)
        if fire == 'gray':
            self.streak.set_css_classes(["nostreak","gstreak"])
        elif fire == 'orange':
            self.streak.set_css_classes(["streak","gstreak"])
        self.tbox.set_center_widget(self.title)
        self.tbox.set_end_widget(self.lives)
        self.sidecut = Gtk.CenterBox(hexpand=True,vexpand=True)
        self.profbox.append(self.sidecut)
        self.leftprof = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, vexpand=True,halign=Gtk.Align.START)
        self.leftprof.set_css_classes(['leftprof'])
        self.rightprof = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, vexpand=True,halign=Gtk.Align.END)
        self.rightprof.set_css_classes(['rightprof'])
        self.sidecut.set_start_widget(self.leftprof)
        self.sidecut.set_end_widget(self.rightprof)
        self.profentry = Gtk.Entry()
        self.rightprof.append(self.profentry)
        self.profentry.connect('activate',changeprof, self, f"io.github.wilwe.duo{profile}")
        self.profnamelab = Gtk.Label(label=f"{profile}:")
        self.lerntypelab = Gtk.Label(label=f"Type: {typ}")
        self.profnamelab.set_justify(Gtk.Justification.LEFT)
        self.lerntypelab.set_justify(Gtk.Justification.LEFT)
        self.leftprof.append(self.profnamelab)
        self.leftprof.append(self.lerntypelab)

    def ssw(self, *args, **kwargs):
        global sound, conf
        if sound:
            sound = False
            self.title.set_label("Sounds Off")
            conf.update({'sound': False})
            with open(path, "w") as f:
                yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
        else:
            sound = True
            self.title.set_label("Sounds On")
            conf.update({'sound': True})
            with open(path, "w") as f:
                yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
    def hmode(self, *args, **kwargs):
        global hard, conf
        if hard:
            hard = False
            self.title.set_label("Hardmode Off")
            conf.update({'hard': False})
            with open(path, "w") as f:
                yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
        else:
            hard = True
            self.title.set_label("Hardmode On")
            conf.update({'hard': True})
            with open(path, "w") as f:
                yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
    def ssl(self, *args, **kwargs):
        global lessonLength, conf
        count = self.setllen.get_value_as_int()
        lessonLength = count
        conf.update({'length': count})
        with open(path, "w") as f:
            yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
    def initplay(self, *args, **kwargs):
        global lesson
        if lives > 0:
            lesson = 0
            self.play()
        else:
            self.title.set_label("You don't have lifes")
    def play(self, *args, **kwargs):
        global lesson, mod
        if lesson < lessonLength:
            lesson +=1
            self.exbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
            self.set_child(self.exbox)
            self.tbox = Gtk.CenterBox(hexpand=True)
            self.exbox.append(self.tbox)
            self.title = Gtk.Label(label=f"Exercise {lesson}/{lessonLength}",wrap=True,justify='center')
            self.lives = Gtk.Label(label=f"{lives}ü´Ä")
            self.streak = Gtk.Label(label=f"{streak} Û∞à∏")
            self.lives.set_css_classes(["lifes"])
            self.tbox.set_start_widget(self.streak)
            if fire == 'gray':
                self.streak.set_css_classes(["nostreak","gstreak"])
            elif fire == 'orange':
                self.streak.set_css_classes(["streak","gstreak"])
            self.tbox.set_center_widget(self.title)
            self.tbox.set_end_widget(self.lives)
            self.ppbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL,hexpand=True,vexpand=True)
            self.ppbox.set_css_classes(['ppbox'])
            self.nextbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL,hexpand=True,vexpand=True,valign=Gtk.Align.END)
            self.exbox.append(self.ppbox)
            modes = ["qchoice","qrevchoice","qchar","qrevchar"]
            mod = random.choice(modes)
            eval(f"self.{mod}()")
        elif lesson == lessonLength:
            streakf()
            self.menu()

    def qchoice(self, *args, **kwargs) -> None:
        global wors, wor
        wor = w.word()
        self.mword = Gtk.Label(label=translate(wor))
        self.mword.set_css_classes(['word'])
        self.ppbox.append(self.mword)
        if not hard:
            wors = w.random_words(4, word_min_length=len(wor), word_max_length=len(wor))
            wors[random.randint(0,3)] = wor
            self.w1 = Gtk.Button(label=wors[0])
            self.w1.connect('clicked', self.checkbut, 0)
            self.w2 = Gtk.Button(label=wors[1])
            self.w2.connect('clicked', self.checkbut, 1)
            self.w3 = Gtk.Button(label=wors[2])
            self.w3.connect('clicked', self.checkbut, 2)
            self.w4 = Gtk.Button(label=wors[3])
            self.w4.connect('clicked', self.checkbut, 3)
            self.w1.set_size_request(width=150,height=150)
            self.w2.set_size_request(width=150,height=150)
            self.w3.set_size_request(width=150,height=150)
            self.w4.set_size_request(width=150,height=150)
            self.toppbox = Gtk.CenterBox()
            self.botppbox = Gtk.CenterBox()
            self.botppbox.set_css_classes(['botppbox'])
            self.ppbox.append(self.toppbox)
            self.ppbox.append(self.botppbox)
            self.tpbo = Gtk.Box()
            self.tpbo.append(self.w1)
            self.tpbo.append(self.w2)
            self.toppbox.set_center_widget(self.tpbo)
            self.btbo = Gtk.Box()
            self.btbo.append(self.w3)
            self.btbo.append(self.w4)
            self.botppbox.set_center_widget(self.btbo)
        else:
            self.showkeys(menu='nextbox')
        self.next = Gtk.Button(label="next")
        self.ppbox.append(self.nextbox)
        self.next.set_css_classes(['next'])
        self.nextbox.append(self.next)
        self.next.connect('clicked', self.play)
        self.next.set_sensitive(False)

    def qrevchoice(self, *args, **kwargs) -> None:
        global wors, wor
        wor = w.word()
        self.mword = Gtk.Label(label=wor)
        wor = translate(wor)
        self.mword.set_css_classes(['word'])
        self.ppbox.append(self.mword)
        if not hard:
            wors = []
            for i in range(4):
                wors.append(translate(w.word(word_min_length=len(wor), word_max_length=len(wor))))
            wors[random.randint(0,3)] = wor
            self.w1 = Gtk.Button(label=wors[0])
            self.w1.connect('clicked', self.checkbut, 0)
            self.w2 = Gtk.Button(label=wors[1])
            self.w2.connect('clicked', self.checkbut, 1)
            self.w3 = Gtk.Button(label=wors[2])
            self.w3.connect('clicked', self.checkbut, 2)
            self.w4 = Gtk.Button(label=wors[3])
            self.w4.connect('clicked', self.checkbut, 3)
            self.w1.set_size_request(width=150,height=150)
            self.w2.set_size_request(width=150,height=150)
            self.w3.set_size_request(width=150,height=150)
            self.w4.set_size_request(width=150,height=150)
            self.toppbox = Gtk.CenterBox()
            self.botppbox = Gtk.CenterBox()
            self.botppbox.set_css_classes(['botppbox'])
            self.ppbox.append(self.toppbox)
            self.ppbox.append(self.botppbox)
            self.tpbo = Gtk.Box()
            self.tpbo.append(self.w1)
            self.tpbo.append(self.w2)
            self.toppbox.set_center_widget(self.tpbo)
            self.btbo = Gtk.Box()
            self.btbo.append(self.w3)
            self.btbo.append(self.w4)
            self.botppbox.set_center_widget(self.btbo)
        else:
            self.showkeys(menu='nextbox')
        self.next = Gtk.Button(label="next")
        self.ppbox.append(self.nextbox)
        self.next.set_css_classes(['next'])
        self.nextbox.append(self.next)
        self.next.connect('clicked', self.play)
        self.next.set_sensitive(False)
    def qchar(self, *args, **kwargs) -> None:
        global wors, wor
        streakf()
        wor = random.choice(string.ascii_lowercase)
        self.mword = Gtk.Label(label=translate(wor))
        self.mword.set_css_classes(['word'])
        self.ppbox.append(self.mword)
        if not hard:
            wors = [random.choice(string.ascii_lowercase) for i in range(4)]
            wors[random.randint(0,3)] = wor
            self.w1 = Gtk.Button(label=wors[0])
            self.w1.connect('clicked', self.checkbut, 0)
            self.w2 = Gtk.Button(label=wors[1])
            self.w2.connect('clicked', self.checkbut, 1)
            self.w3 = Gtk.Button(label=wors[2])
            self.w3.connect('clicked', self.checkbut, 2)
            self.w4 = Gtk.Button(label=wors[3])
            self.w4.connect('clicked', self.checkbut, 3)
            self.w1.set_size_request(width=150,height=150)
            self.w2.set_size_request(width=150,height=150)
            self.w3.set_size_request(width=150,height=150)
            self.w4.set_size_request(width=150,height=150)
            self.toppbox = Gtk.CenterBox()
            self.botppbox = Gtk.CenterBox()
            self.botppbox.set_css_classes(['botppbox'])
            self.ppbox.append(self.toppbox)
            self.ppbox.append(self.botppbox)
            self.tpbo = Gtk.Box()
            self.tpbo.append(self.w1)
            self.tpbo.append(self.w2)
            self.toppbox.set_center_widget(self.tpbo)
            self.btbo = Gtk.Box()
            self.btbo.append(self.w3)
            self.btbo.append(self.w4)
            self.botppbox.set_center_widget(self.btbo)
        else:
            self.showkeys(menu='nextbox')
        self.next = Gtk.Button(label="next")
        self.ppbox.append(self.nextbox)
        self.next.set_css_classes(['next'])
        self.nextbox.append(self.next)
        self.next.connect('clicked', self.play)
        self.next.set_sensitive(False)

    def qrevchar(self, *args, **kwargs) -> None:
        global wors, wor
        wor = random.choice(string.ascii_lowercase)
        self.mword = Gtk.Label(label=wor)
        wor = translate(wor)
        self.mword.set_css_classes(['word'])
        self.ppbox.append(self.mword)
        if not hard:
            wors = []
            for i in range(4):
                wors.append(translate(random.choice(string.ascii_lowercase)))
            wors[random.randint(0,3)] = wor
            self.w1 = Gtk.Button(label=wors[0])
            self.w1.connect('clicked', self.checkbut, 0)
            self.w2 = Gtk.Button(label=wors[1])
            self.w2.connect('clicked', self.checkbut, 1)
            self.w3 = Gtk.Button(label=wors[2])
            self.w3.connect('clicked', self.checkbut, 2)
            self.w4 = Gtk.Button(label=wors[3])
            self.w4.connect('clicked', self.checkbut, 3)
            self.w1.set_size_request(width=150,height=150)
            self.w2.set_size_request(width=150,height=150)
            self.w3.set_size_request(width=150,height=150)
            self.w4.set_size_request(width=150,height=150)
            self.toppbox = Gtk.CenterBox()
            self.botppbox = Gtk.CenterBox()
            self.botppbox.set_css_classes(['botppbox'])
            self.ppbox.append(self.toppbox)
            self.ppbox.append(self.botppbox)
            self.tpbo = Gtk.Box()
            self.tpbo.append(self.w1)
            self.tpbo.append(self.w2)
            self.toppbox.set_center_widget(self.tpbo)
            self.btbo = Gtk.Box()
            self.btbo.append(self.w3)
            self.btbo.append(self.w4)
            self.botppbox.set_center_widget(self.btbo)
        else:
            self.showkeys(menu="nextbox")
        self.next = Gtk.Button(label="next")
        self.ppbox.append(self.nextbox)
        self.next.set_css_classes(['next'])
        self.nextbox.append(self.next)
        self.next.connect('clicked', self.play)
        self.next.set_sensitive(False)
    def checkbut(self, sus, val, *args, **kwargs):
        if wors[val] == wor:
            if mod == 'qchar':
                self.exppl(lvl+streak+5)
            if mod == 'qrevchar':
                self.exppl(lvl+streak+10)
            if mod == 'qchoice':
                self.exppl(lvl+streak+10)
            if mod == 'qrevchoice':
                self.exppl(lvl+streak+15)
            self.title.set_label(f"Good {lesson}/{lessonLength}")
            self.title.set_css_classes(['good'])
            self.mword.add_css_class('good')
            for i in range(4):
                if wors[i] != wor:
                    eval(f"self.w{i+1}").set_visible(False)
                else:
                    eval(f"self.w{i+1}").set_sensitive(False)
            self.next.set_sensitive(True)
            self.next.grab_focus()
            if sound:
                playsound('good.mp3')
        else:
            self.title.set_label(f"Wrong {lesson}/{lessonLength}")
            self.title.set_css_classes(['wrong'])
            self.mword.add_css_class('wrong')
            self.lifedel(count=1)
            for i in range(4):
                if wors[i] != wor:
                    eval(f"self.w{i+1}").set_visible(False)
                else:
                    eval(f"self.w{i+1}").set_sensitive(False)
            self.next.set_sensitive(True)
            self.next.grab_focus()
            if sound:
                playsound('bad.mp3')

    def exppl(self, count = None, check = False, *args, **kwargs) -> None:
        global exp, lvl, lvlup
        lvlup = False
        if count != None:
            exp += count
            conf.update({"exp": exp, "lvl": lvl})
            with open(path, "w") as f:
                yaml.dump(conf, f, allow_unicode=True, sort_keys=False)
        if check:
            while exp >= ((lvl+1)*4)*(lvl+3):
                exp -= ((lvl+1)*4)*(lvl+3)
                lvl += 1
                lvlup = True
            conf.update({"exp": exp, "lvl": lvl})
            self.setprog()
            with open(path, "w") as f:
                yaml.dump(conf, f, allow_unicode=True, sort_keys=False)

    def showkeys(self, iys = None, menu = None, *args, **kwargs):
        global koks, men
        if menu != None:
            men = menu
        if not koks or menu == 'nextbox':
            koks = True
            keys = []
            values = []
            for key, value in lern.items():
                keys.append(key)
                values.append(value)
            random.shuffle(keys)
            shufla = {}
            for key in keys:
                shufla[key] = lern[key]
            k = 0
            box = 1
            self.keyboard = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
            self.keyboard.set_css_classes(['keyboard'])
            exec(f"self.{menu}.append(self.keyboard)")
            self.txt = Gtk.Entry()
            self.txt.set_placeholder_text("Write text here...")
            self.txt.set_css_classes(['txtentry'])
            self.txt.connect('activate',self.upload,menu)
            self.keyboard.append(self.txt)
            self.kbox1 = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL,halign=Gtk.Align.CENTER,valign=Gtk.Align.END)
            self.keyboard.append(self.kbox1)
            for key, value in shufla.items():
                if k == 10:
                    k = 0
                    box += 1
                    exec(f"self.kbox{box} = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL,halign=Gtk.Align.CENTER,valign=Gtk.Align.END)")
                    exec(f"self.keyboard.append(self.kbox{box})")
                if key in string.ascii_lowercase:
                    k +=1
                    exec(f"self.key{key} = Gtk.Button(label=value)")
                    exec(f"self.key{key}.connect('clicked', self.kentadd, value)")
                    eval(f"self.kbox{box}.append(self.key{key})")
            self.bottomtext = Gtk.Box(hexpand=True)
            self.space = Gtk.Button(label="Space",hexpand=True)
            self.space.connect('clicked', self.kentadd, " ")
            self.backspace = Gtk.Button(label="Backspace",hexpand=True)
            self.backspace.connect('clicked', self.kentback)
            self.enter = Gtk.Button(label="Enter",hexpand=True)
            self.enter.connect('clicked', self.upload)
            self.bottomtext.append(self.backspace)
            self.bottomtext.append(self.space)
            self.bottomtext.append(self.enter)
            self.keyboard.append(self.bottomtext)
        else:
            koks = False
            for i in range(10):
                try:
                    exec(f"self.optbox.remove(self.kbox{i})")
                except:
                    pass
    def upload(self, obj, menu = None, *args, **kwargs):
        global men
        if menu != None:
            men = menu
        if men == 'optbox':
            print(self.txt.get_text())
        if men == 'nextbox':
            if self.txt.get_text() == wor:
                if mod == 'qchar':
                    self.exppl((lvl+streak+5)*2)
                if mod == 'qrevchar':
                    self.exppl((lvl+streak+10)*2)
                if mod == 'qchoice':
                    self.exppl((lvl+streak+10)*2)
                if mod == 'qrevchoice':
                    self.exppl((lvl+streak+15)*2)
                self.title.set_label(f"Good {lesson}/{lessonLength}")
                self.title.set_css_classes(['good'])
                self.mword.add_css_class('good')
                self.txt.set_sensitive(False)
                self.next.set_sensitive(True)
                self.next.grab_focus()
                if sound:
                    playsound('good.mp3')
            else:
                self.title.set_label(f"Wrong {lesson}/{lessonLength}")
                self.title.set_css_classes(['wrong'])
                self.mword.add_css_class('wrong')
                self.lifedel(count=1)
                self.txt.set_text(wor)
                self.txt.set_sensitive(False)
                self.next.set_sensitive(True)
                self.next.grab_focus()
                if sound:
                    playsound('bad.mp3')
    def kentadd(self, obj, add, *args, **kwargs):
        current_text = self.txt.get_text()
        self.txt.set_text(current_text + add)
        self.txt.grab_focus()
        self.txt.select_region(-1,-1)
        self.txt.set_position(len(current_text)+1)
    def kentback(self, *args, **kwargs):
        current_text = self.txt.get_text()
        self.txt.set_text(current_text[:-1])
        self.txt.grab_focus()
        self.txt.select_region(-1,-1)
        self.txt.set_position(len(current_text)-1)
    def lifedel(self, obj = None, count = None, *args, **kwargs):
        global lives, ldat
        lives -= count
        if lives+1 == maxlive:
            ldat = ftime + datetime.timedelta(minutes=30) 
            conf.update({"lives": lives, "ldat": ldat})
        else:
            conf.update({"lives": lives})
        with open(path, "w") as f:
            yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
    def exit(self, *args, **kwargs):
        exit()
class App(Adw.Application):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.connect("activate", self.on_activate)
    def on_activate(self,app):
        self.win = MainWindow(application=app)
        self.win.present()
def translate(word, side = "lern") -> str:
    if side == "lern":
        return ''.join(lern.get(ch,ch) for ch in word)
    if side == "normal":
        for key, value in normdub.items():
            word = word.replace(key, value)
        return ''.join(normsing.get(ch,ch) for ch in word)
def streakf(obj = None, rest: bool = False, check: bool = False) -> None:
    global streak, fire
    up = False
    if check:
        if sdata < time:
            print(smem)
            print("I'm at your door now")
            conf.update({"streak": {"count": 0, "data": time}})
            streak = 0
            up = True 
        elif sdata == time:
            fire = "gray"
        elif sdata > time:
            fire = "orange"
    else:
        if rest:
            print("Streak reset")
            ssts = time - relativedelta(days=1)
            ssts = ssts.strftime("%Y.%m.%d")
            conf.update({"streak": {"count": 0, "data": ssts}})
            streak = 0
            up = True
        else:
            nex = sdata + relativedelta(days=1)
            if sdata <= ftime:
                ssts = time + relativedelta(days=1)
                ssts = ssts.strftime("%Y.%m.%d")
                fire = 'orange'
                conf.update({"streak": {"count": streak+1, "data": ssts}})
                streak += 1
                up = True
                print(f"Your streak raise: {streak}")
    if up:
        with open(path, "w") as f:
            yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
def livs() -> None:
    global lives, ldat
    if lives != maxlive and ftime > ldat:
        lives += 1
        ldat = ldat + datetime.timedelta(minutes=30)
        if lives == maxlive:
            conf.update({"lives": lives, "ldat": None})
        else:
            conf.update({"lives": lives, "ldat": ldat})
            livs()
        with open(path, "w") as f:
            yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
def changeprof(obj, window, appid):
    global app
    sus = window.profentry.get_text()
    window.destroy()
    main(sus)
def main(prof: str = None) -> None:
    global app, profile, koks, lvlup, fire, exp, time, logo, smem, path, typ, ftime, w, streak, sdata, lives, lvl, ldat, maxlive, lessonLength, conf, first, lern, normsing, normdub, hard, sound
    time = datetime.datetime.strptime(datetime.datetime.now().strftime("%Y.%m.%d"), "%Y.%m.%d")
    ftime = datetime.datetime.now()
    lvlup = False
    first = False
    fire = 'gray'
    if prof == None:
        profile = "Braill"
        path = f"{Path.home()}/.config/duobraill.yaml"
    else:
        profile = prof.title()
        path = f"{Path.home()}/.config/duo{prof.lower()}.yaml"
    try:
        with open(path, "r") as f:
            conf = yaml.load(f, Loader=yaml.FullLoader)
    except FileNotFoundError:
        print("Creating new profile")
        sleep(2)
        first = True
        with open(path, "w+") as f:
            conf = {"logo": "Welcome to duolingo for blind", "smem": "Your streak gone","streak": {"count": 0, "data": time.strftime("%Y.%m.%d")}, "type": "lang", "lvl": 0, "exp": 0, "hard": False, "sound": True, "lives": 5, "maxlives": 5, "ldat": ftime, "length": 5}
            yaml.dump(conf, f, allow_unicode=True, sort_keys=False)
    try:
        logo = conf["logo"]
    except:
        logo = "Welcome to duolingo"
    try:
        smem = conf["smem"]
    except:
        smem = "Your streak gone"
    typ = conf["type"]
    streak = conf["streak"]["count"]
    sdata = datetime.datetime.strptime(conf["streak"]["data"], "%Y.%m.%d")
    lvl = conf["lvl"]
    exp = conf["exp"]
    lives = conf["lives"]
    ldat = conf["ldat"]
    maxlive = conf["maxlives"]
    lessonLength = conf["length"]
    hard = conf["hard"]
    sound = conf["sound"]
    if typ == 'lang':
        try:
            lern = conf["lern"]
        except:
            lern = {"a": "‚†Å","b": "‚†É","c": "‚†â","d": "‚†ô","e": "‚†ë","f": "‚†ã","g": "‚†õ","h": "‚†ì","i": "‚†ä","j": "‚†ö","k": "‚†Ö","l": "‚†á","m": "‚†ç","n": "‚†ù","o": "‚†ï","p": "‚†è","q": "‚†ü","r": "‚†ó","s": "‚†é","t": "‚†û","u": "‚†•","v": "‚†ß","w": "‚†∫","x": "‚†≠","y": "‚†Ω","z": "‚†µ","ƒÖ":"‚†°","ƒá":"‚†©","ƒô":"‚†±","≈Ç":"‚†£","≈Ñ":"‚†π","√≥":"‚†¨","≈õ":"‚†™","≈º":"‚†Ø","≈∫":"‚†Æ","0":"‚†º‚†ö","1":"‚†º‚†Å","2":"‚†º‚†É","3":"‚†º‚†â","4":"‚†º‚†ô","5":"‚†º‚†ë","6":"‚†º‚†ã","7":"‚†º‚†õ","8":"‚†º‚†ì","9":"‚†º‚†ä","-": "‚†í",".": "‚†≤","'": "‚°Ä",",": "‚†Ç"}
        try:
            normsing = conf["normal"]["single"]
        except:
            normsing = {"‚†Å":"a","‚†É":"b","‚†â":"c","‚†ô":"d","‚†ë":"e","‚†ã":"f","‚†õ":"g","‚†ì":"h","‚†ä":"i","‚†ö":"j","‚†Ö":"k","‚†á":"l","‚†ç":"m","‚†ù":"n","‚†ï":"o","‚†è":"p","‚†ü":"q","‚†ó":"r","‚†é":"s","‚†û":"t","‚†•":"u","‚†ß":"v","‚†∫":"w","‚†≠":"x","‚†Ω":"y","‚†µ":"z","‚†°":"ƒÖ","‚†©":"ƒá","‚†±":"ƒô","‚†£":"≈Ç","‚†π":"≈Ñ","‚†¨":"√≥","‚†™":"≈õ","‚†Ø":"≈º","‚†Æ":"≈∫","-": "‚†í",".":"‚†≤","'": "‚°Ä",",":"‚†Ç"}
        try:
            normdub = conf["normal"]["dubles"]
        except:
            normdub = {"‚†º‚†ö": "0","‚†º‚†Å": "1", "‚†º‚†É": "2","‚†º‚†â": "3","‚†º‚†ô": "4","‚†º‚†ë": "5","‚†º‚†ã": "6","‚†º‚†õ": "7","‚†º‚†ì": "8","‚†º‚†ä": "9"}
    w = wonderwords.RandomWord()
    if not first:
        streakf(check = True)
    koks = False
    app = App(application_id=f"io.github.wilwe.duo{profile}{random.randint(0,999999)}")
    app.run()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-p", "--profile", help="set profile", nargs="*",default=None)
    args = parser.parse_args()
    if args.profile != None:
        args.profile = ' '.join(args.profile)
    main(args.profile)
