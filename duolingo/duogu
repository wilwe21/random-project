#!/usr/bin/env python3
import sys
import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import Gtk, Gdk, Adw
import yaml, argparse, random, wonderwords, datetime, string 
from time import sleep
from dateutil.relativedelta import relativedelta
from pathlib import Path
css_provider = Gtk.CssProvider()
css_provider.load_from_path('style.css')
Gtk.StyleContext.add_provider_for_display(Gdk.Display.get_default(), css_provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
class MainWindow(Gtk.ApplicationWindow):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.menu()
    def menu(self, *args, **kwargs):
        livs()
        self.mainbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.set_child(self.mainbox)
        self.tbox = Gtk.CenterBox(hexpand=True)
        self.mainbox.append(self.tbox)
        self.title = Gtk.Label(label=logo,wrap=True,justify='center')
        self.lives = Gtk.Label(label=f"{lives}🫀")
        self.streak = Gtk.Label(label=f"{streak} 󰈸")
        self.lives.set_css_classes(["lifes"])
        self.tbox.set_start_widget(self.streak)
        if fire == 'gray':
            self.streak.set_css_classes(["nostreak","gstreak"])
        elif fire == 'orange':
            self.streak.set_css_classes(["streak","gstreak"])
        self.tbox.set_center_widget(self.title)
        self.tbox.set_end_widget(self.lives)
        self.bbox = Gtk.Box(hexpand=True)
        self.mainbox.append(self.bbox)
        self.playbut = Gtk.Button(label="Play", hexpand=True)
        self.playbut.connect('clicked', self.initplay)
        self.options = Gtk.Button(label="Options", hexpand=True)
        self.options.connect('clicked', self.opt)
        self.exitb = Gtk.Button(label="Exit", hexpand=True)
        self.exitb.connect('clicked', self.exit)
        self.bbox.append(self.playbut)
        self.bbox.append(self.options)
        self.bbox.append(self.exitb)
    def opt(self, *args, **kwargs):
        self.optbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL,vexpand=True)
        self.set_child(self.optbox)
        self.tbox = Gtk.CenterBox(hexpand=True)
        self.optbox.append(self.tbox)
        self.title = Gtk.Label(label=logo,wrap=True,justify='center')
        self.lives = Gtk.Label(label=f"{lives}🫀")
        self.streak = Gtk.Label(label=f"{streak} 󰈸")
        self.lives.set_css_classes(["lifes"])
        self.tbox.set_start_widget(self.streak)
        if fire == 'gray':
            self.streak.set_css_classes(["nostreak","gstreak"])
        elif fire == 'orange':
            self.streak.set_css_classes(["streak","gstreak"])
        self.tbox.set_center_widget(self.title)
        self.tbox.set_end_widget(self.lives)
        self.opts = Gtk.Box(hexpand=True)
        self.opts.set_css_classes(['optsbox'])
        self.optbox.append(self.opts)
        self.reststreak = Gtk.Button(label='Reset Streak',hexpand=True)
        self.showkeyboard = Gtk.Button(label='Show Keyboard',hexpand=True)
        self.showkeyboard.connect('clicked', self.showkeys, "optbox")
        self.back = Gtk.Button(label='Back',hexpand=True)
        self.back.connect('clicked', self.menu)
        self.opts.append(self.reststreak)
        self.opts.append(self.showkeyboard)
        self.opts.append(self.back)
    def initplay(self, *args, **kwargs):
        global lesson
        lesson = 0
        self.play()
    def play(self, *args, **kwargs):
        global lesson
        if lesson < lessonLength:
            lesson +=1
            self.exbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
            self.set_child(self.exbox)
            self.tbox = Gtk.CenterBox(hexpand=True)
            self.exbox.append(self.tbox)
            self.title = Gtk.Label(label=f"Exercise {lesson}/{lessonLength}",wrap=True,justify='center')
            self.lives = Gtk.Label(label=f"{lives}🫀")
            self.streak = Gtk.Label(label=f"{streak} 󰈸")
            self.lives.set_css_classes(["lifes"])
            self.tbox.set_start_widget(self.streak)
            if fire == 'gray':
                self.streak.set_css_classes(["nostreak","gstreak"])
            elif fire == 'orange':
                self.streak.set_css_classes(["streak","gstreak"])
            self.tbox.set_center_widget(self.title)
            self.tbox.set_end_widget(self.lives)
            self.ppbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL,hexpand=True,vexpand=True)
            self.exbox.append(self.ppbox)
            modes = ["qchoice","qrevchoice","qchar","qrevchar"]
            mod = random.choice(modes)
            eval(f"self.{mod}()")
        elif lesson == lessonLength:
            self.menu()

    def qchoice(self, *args, **kwargs) -> None:
        global wors, wor
        wor = w.word()
        self.mword = Gtk.Label(label=translate(wor))
        self.mword.set_css_classes(['word'])
        self.ppbox.append(self.mword)
        wors = w.random_words(4, word_min_length=len(wor), word_max_length=len(wor))
        wors[random.randint(0,3)] = wor
        self.w1 = Gtk.Button(label=wors[0])
        self.w1.connect('clicked', self.checkbut, 0)
        self.w2 = Gtk.Button(label=wors[1])
        self.w2.connect('clicked', self.checkbut, 1)
        self.w3 = Gtk.Button(label=wors[2])
        self.w3.connect('clicked', self.checkbut, 2)
        self.w4 = Gtk.Button(label=wors[3])
        self.w4.connect('clicked', self.checkbut, 3)
        self.w1.set_size_request(width=150,height=150)
        self.w2.set_size_request(width=150,height=150)
        self.w3.set_size_request(width=150,height=150)
        self.w4.set_size_request(width=150,height=150)
        self.toppbox = Gtk.CenterBox()
        self.botppbox = Gtk.CenterBox()
        self.botppbox.set_css_classes(['botppbox'])
        self.ppbox.append(self.toppbox)
        self.ppbox.append(self.botppbox)
        self.tpbo = Gtk.Box()
        self.tpbo.append(self.w1)
        self.tpbo.append(self.w2)
        self.toppbox.set_center_widget(self.tpbo)
        self.btbo = Gtk.Box()
        self.btbo.append(self.w3)
        self.btbo.append(self.w4)
        self.botppbox.set_center_widget(self.btbo)
        self.next = Gtk.Button(label="next")
        self.next.set_css_classes(['next'])
        self.ppbox.append(self.next)
        self.next.connect('clicked', self.play)
        self.next.set_visible(False)

    def qrevchoice(self, *args, **kwargs) -> None:
        global wors, wor
        wor = w.word()
        self.mword = Gtk.Label(label=wor)
        wor = translate(wor)
        self.mword.set_css_classes(['word'])
        self.ppbox.append(self.mword)
        wors = []
        for i in range(4):
            wors.append(translate(w.word(word_min_length=len(wor), word_max_length=len(wor))))
        wors[random.randint(0,3)] = wor
        self.w1 = Gtk.Button(label=wors[0])
        self.w1.connect('clicked', self.checkbut, 0)
        self.w2 = Gtk.Button(label=wors[1])
        self.w2.connect('clicked', self.checkbut, 1)
        self.w3 = Gtk.Button(label=wors[2])
        self.w3.connect('clicked', self.checkbut, 2)
        self.w4 = Gtk.Button(label=wors[3])
        self.w4.connect('clicked', self.checkbut, 3)
        self.w1.set_size_request(width=150,height=150)
        self.w2.set_size_request(width=150,height=150)
        self.w3.set_size_request(width=150,height=150)
        self.w4.set_size_request(width=150,height=150)
        self.toppbox = Gtk.CenterBox()
        self.botppbox = Gtk.CenterBox()
        self.botppbox.set_css_classes(['botppbox'])
        self.ppbox.append(self.toppbox)
        self.ppbox.append(self.botppbox)
        self.tpbo = Gtk.Box()
        self.tpbo.append(self.w1)
        self.tpbo.append(self.w2)
        self.toppbox.set_center_widget(self.tpbo)
        self.btbo = Gtk.Box()
        self.btbo.append(self.w3)
        self.btbo.append(self.w4)
        self.botppbox.set_center_widget(self.btbo)
        self.next = Gtk.Button(label="next")
        self.next.set_css_classes(['next'])
        self.ppbox.append(self.next)
        self.next.connect('clicked', self.play)
        self.next.set_visible(False)
    def qchar(self, *args, **kwargs) -> None:
        global wors, wor
        wor = random.choice(string.ascii_lowercase)
        wors = [random.choice(string.ascii_lowercase) for i in range(4)]
        wors[random.randint(0,3)] = wor
        self.mword = Gtk.Label(label=translate(wor))
        self.mword.set_css_classes(['word'])
        self.ppbox.append(self.mword)
        self.w1 = Gtk.Button(label=wors[0])
        self.w1.connect('clicked', self.checkbut, 0)
        self.w2 = Gtk.Button(label=wors[1])
        self.w2.connect('clicked', self.checkbut, 1)
        self.w3 = Gtk.Button(label=wors[2])
        self.w3.connect('clicked', self.checkbut, 2)
        self.w4 = Gtk.Button(label=wors[3])
        self.w4.connect('clicked', self.checkbut, 3)
        self.w1.set_size_request(width=150,height=150)
        self.w2.set_size_request(width=150,height=150)
        self.w3.set_size_request(width=150,height=150)
        self.w4.set_size_request(width=150,height=150)
        self.toppbox = Gtk.CenterBox()
        self.botppbox = Gtk.CenterBox()
        self.botppbox.set_css_classes(['botppbox'])
        self.ppbox.append(self.toppbox)
        self.ppbox.append(self.botppbox)
        self.tpbo = Gtk.Box()
        self.tpbo.append(self.w1)
        self.tpbo.append(self.w2)
        self.toppbox.set_center_widget(self.tpbo)
        self.btbo = Gtk.Box()
        self.btbo.append(self.w3)
        self.btbo.append(self.w4)
        self.botppbox.set_center_widget(self.btbo)
        self.next = Gtk.Button(label="next")
        self.next.set_css_classes(['next'])
        self.ppbox.append(self.next)
        self.next.connect('clicked', self.play)
        self.next.set_visible(False)

    def qrevchar(self, *args, **kwargs) -> None:
        global wors, wor
        wor = random.choice(string.ascii_lowercase)
        wors = []
        for i in range(4):
            wors.append(random.choice(string.ascii_lowercase))
        wors[random.randint(0,3)] = wor
        self.mword = Gtk.Label(label=translate(wor))
        self.mword.set_css_classes(['word'])
        self.ppbox.append(self.mword)
        self.w1 = Gtk.Button(label=wors[0])
        self.w1.connect('clicked', self.checkbut, 0)
        self.w2 = Gtk.Button(label=wors[1])
        self.w2.connect('clicked', self.checkbut, 1)
        self.w3 = Gtk.Button(label=wors[2])
        self.w3.connect('clicked', self.checkbut, 2)
        self.w4 = Gtk.Button(label=wors[3])
        self.w4.connect('clicked', self.checkbut, 3)
        self.w1.set_size_request(width=150,height=150)
        self.w2.set_size_request(width=150,height=150)
        self.w3.set_size_request(width=150,height=150)
        self.w4.set_size_request(width=150,height=150)
        self.toppbox = Gtk.CenterBox()
        self.botppbox = Gtk.CenterBox()
        self.botppbox.set_css_classes(['botppbox'])
        self.ppbox.append(self.toppbox)
        self.ppbox.append(self.botppbox)
        self.tpbo = Gtk.Box()
        self.tpbo.append(self.w1)
        self.tpbo.append(self.w2)
        self.toppbox.set_center_widget(self.tpbo)
        self.btbo = Gtk.Box()
        self.btbo.append(self.w3)
        self.btbo.append(self.w4)
        self.botppbox.set_center_widget(self.btbo)
        self.next = Gtk.Button(label="next")
        self.next.set_css_classes(['next'])
        self.ppbox.append(self.next)
        self.next.connect('clicked', self.play)
        self.next.set_visible(False)
    def checkbut(self, sus, val, *args, **kwargs):
        if wors[val] == wor:
            self.title.set_label("Good")
            self.title.set_css_classes(['good'])
            self.mword.add_css_class('good')
            for i in range(4):
                if wors[i] != wor:
                    eval(f"self.w{i+1}").set_visible(False)
                else:
                    eval(f"self.w{i+1}").set_sensitive(False)
            self.next.set_visible(True)
        else:
            self.title.set_label("Wrong")
            self.title.set_css_classes(['wrong'])
            self.mword.add_css_class('wrong')
            for i in range(4):
                if wors[i] != wor:
                    eval(f"self.w{i+1}").set_visible(False)
                else:
                    eval(f"self.w{i+1}").set_sensitive(False)
            self.next.set_visible(True)

    def showkeys(self, iys = None, menu = None, *args, **kwargs):
        global koks
        if not koks:
            koks = True
            keys = []
            values = []
            for key, value in lern.items():
                keys.append(key)
                values.append(value)
            random.shuffle(keys)
            shufla = {}
            for key in keys:
                shufla[key] = lern[key]
            k = 0
            box = 1
            self.txt = Gtk.Entry()
            self.txt.set_placeholder_text("Write text here...")
            self.txt.set_css_classes(['txtentry'])
            self.txt.connect('activate',self.upload)
            exec(f"self.{menu}.append(self.txt)")
            self.kbox1 = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL,halign=Gtk.Align.CENTER,valign=Gtk.Align.END)
            exec(f"self.{menu}.append(self.kbox1)")
            for key, value in shufla.items():
                if k == 10:
                    k = 0
                    box += 1
                    exec(f"self.kbox{box} = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL,halign=Gtk.Align.CENTER,valign=Gtk.Align.END)")
                    exec(f"self.{menu}.append(self.kbox{box})")
                if key in string.ascii_lowercase:
                    k +=1
                    exec(f"self.key{key} = Gtk.Button(label=value)")
                    exec(f"self.key{key}.connect('clicked', self.kentadd, value)")
                    eval(f"self.kbox{box}.append(self.key{key})")
            self.bottomtext = Gtk.Box(hexpand=True)
            self.space = Gtk.Button(label="Space",hexpand=True)
            self.space.connect('clicked', self.kentadd, " ")
            self.backspace = Gtk.Button(label="Backspace",hexpand=True)
            self.backspace.connect('clicked', self.kentback)
            self.enter = Gtk.Button(label="Enter",hexpand=True)
            self.enter.connect('clicked', self.kentadd, "chuj potem się tym zajmę")
            self.bottomtext.append(self.backspace)
            self.bottomtext.append(self.space)
            self.bottomtext.append(self.enter)
            exec(f"self.{menu}.append(self.bottomtext)")
        else:
            koks = False
            for i in range(10):
                try:
                    exec(f"self.optbox.remove(self.kbox{i})")
                except:
                    pass
    def upload(self, *args, **kwargs):
        print(self.txt.get_text())
    def kentadd(self, obj, add, *args, **kwargs):
        current_text = self.txt.get_text()
        self.txt.set_text(current_text + add)
    def kentback(self, *args, **kwargs):
        current_text = self.txt.get_text()
        self.txt.set_text(current_text[:-1])
    def exit(self, *args, **kwargs):
        exit()
class App(Adw.Application):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.connect("activate", self.on_activate)
    def on_activate(self,app):
        self.win = MainWindow(application=app)
        self.win.present()
def translate(word, side = "lern") -> str:
    if side == "lern":
        return ''.join(lern.get(ch,ch) for ch in word)
    if side == "normal":
        for key, value in normdub.items():
            word = word.replace(key, value)
        return ''.join(normsing.get(ch,ch) for ch in word)
def qchoicehard() -> None:
    wor = w.word()
    print(f"{translate(wor)} means")
    try:
        ans = input("")
    except KeyboardInterrupt:
        exit()
    if ans == wor:
        print("Great")
    else:
        print(f"Correct answer is {wor}")
        raise ValueError("Braille or you'll stay blank")
def qrevchoicehard() -> None:
    wor = w.word()
    print(f"{wor} means")
    alpha(True)
    try:
        ans = input("")
    except KeyboardInterrupt:
        exit()
    if ans == translate(wor):
        print("Great")
    else:
        print(f"Correct answer is {translate(wor)}")
        raise ValueError("Braille or you'll stay blank")
def qcharhard() -> None:
    le = random.choice(string.ascii_lowercase)
    print(f"{translate(le)} is")
    try:
        ans = input("").lower()
    except KeyboardInterrupt:
        exit()
    if ans == le:
        print("Great")
    else:
        print(f"Correct asnwer is {le}")
        raise ValueError("Braille or you'll stay blank")
def qrevcharhard() -> None:
    le = random.choice(string.ascii_lowercase)
    print(f"{le} is")
    alpha(True)
    try:
        ans = input("").lower()
    except KeyboardInterrupt:
        exit()
    if ans == translate(le):
        print("Great")
    else:
        print(f"Correct asnwer is {translate(le)}")
        raise ValueError("Braille or you'll stay blank")
def option() -> None:
    global hard
    print("\033cOptions")
    options = ["reset strek","check lifes","Show alphabet", "set lesson length", "Hard Mode","Back"]
    opts = [f"{options.index(i)+1} {i}" for i in options]
    print('\n'.join(opts))
    loop = True
    while loop:
        try:
            ans = input("Which one: ").lower()
        except KeyboardInterrupt:
            exit()
        if ans in ["reset streak", "1"]:
            streakf(True)
        if ans in ["show alphabet", "3", "show", "alpha"]:
            alpha()
        if ans in ["set lesson length", "4", "len", "set len"]:
            sll()
        if ans in ["hard mode", "5", "hard", "hardmode"]:
            if not conf["hard"]:
                hard = True
                conf.update({"hard": True})
            else:
                hard = False
                conf.update({"hard": False})
            with open(path, "w") as f:
                yaml.dump(conf,f,sort_keys=False,allow_unicode=True)
        if ans in ["back", "6", ":q"]:
            loop = False
            menu()
def sll() -> None:
    global lessonLength
    print(f"Current lesson length {lessonLength}")
    try:
        val = int(input("Set length(length >= 5): "))
        if val < 5:
            raise ValueError()
        loop = False
    except ValueError:
        loop = True
    while loop:
        try:
            val = int(input("Length need to be a number >=5: "))
            if val < 5:
                raise ValueError()
            loop = False
        except ValueError:
            loop = True
    lessonLength = val
    conf.update({"length": val})
    with open(path, "w") as f:
        yaml.dump(conf,f,allow_unicode=True,sort_keys=False)
def play() -> None:
    global lives, ldat
    playmodes = ["char", "revchar", "choice", "revchoice"]
    if lives == 0:
        print("You don't have lifes")
    else:
        for i in range(lessonLength):
            if lives > 0:
                livs()
                try:
                    play = random.choice(playmodes)
                    print(f"Exercise {i+1}/{lessonLength}")
                    if play == "char":
                        if not hard:
                            qchar()
                            exppl(lvl+streak+5)
                        else:
                            qcharhard()
                            exppl((lvl+streak+5)*2)
                    elif play == "choice":
                        if not hard:
                            qchoice()
                            exppl(lvl+streak+10)
                        else:
                            qchoicehard()
                            exppl((lvl+streak+10)*2)
                    if play == "revchar":
                        if not hard:
                            qrevchar()
                            exppl(lvl+streak+10)
                        else:
                            qrevcharhard()
                            exppl((lvl+streak+15)*2)
                    elif play == "revchoice":
                        if not hard:
                            qrevchoice()
                            exppl(lvl+streak+15)
                        else:
                            qrevchoicehard()
                            exppl((lvl+streak+20)*2)
                except ValueError:
                    lives -= 1
                    if lives+1 == maxlive:
                        ldat = ftime + datetime.timedelta(minutes=30) 
                        conf.update({"lives": lives, "ldat": ldat})
                    else:
                        conf.update({"lives": lives})
                    with open(path, "w") as f:
                        yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
            else:
                print("Your lifes are gone")
                print(f"You lose on lesson {i+1}/{lessonLength}")
                break
        if lives > 0:
            if not hard:
                print("Congrats you compleat a lesson")
            else:
                print("Congrats you compleat hard lesson")
            streakf()
def streakf(rest: bool = False, check: bool = False) -> None:
    global streak, fire
    up = False
    if check:
        if sdata < time:
            print(smem)
            print("I'm at your door now")
            conf.update({"streak": {"count": 0, "data": time}})
            streak = 0
            up = True 
        elif sdata == time:
            fire = "gray"
        elif sdata > time:
            fire = "orange"
    else:
        if rest:
            print("Streak reset")
            conf.update({"streak": {"count": 0, "data": (time - relativedelta(days=1)).strftime("%Y.%m.%d")}})
            streak = 0
            up = True
        else:
            nex = sdata + relativedelta(days=1)
            if sdata <= ftime:
                conf.update({"streak": {"count": streak+1, "data": (time + relativedelta(days=1)).strftime("%Y.%m.%d") }})
                streak += 1
                up = True
                print(f"Your streak raise: {streak}")
    if up:
        with open(path, "w") as f:
            yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
def livs(ver: bool = False) -> None:
    global lives, ldat
    if lives != maxlive and ftime > ldat:
        lives += 1
        ldat = ldat + datetime.timedelta(minutes=30)
        if lives == maxlive:
            conf.update({"lives": lives, "ldat": None})
        else:
            conf.update({"lives": lives, "ldat": ldat})
            livs()
        with open(path, "w") as f:
            yaml.dump(conf,f, allow_unicode=True, sort_keys=False)
    elif lives != maxlive and ver:
        print(f"Next lifes come {ldat.strftime('%Y.%m.%d %H:%M:%S')}")
        print(f"You have {lives} lifes")
    elif lives == maxlive and ver:
        print("You have maximum amount of lifes")
        print(f"You have {lives} lifes")
def exppl(count: int = None) -> None:
    global exp, lvl
    if count != None:
        exp += count
        if exp >= ((lvl+1)*4)**(lvl+3):
            lvl += 1
            print(f"Lvl up {lvl}")
        conf.update({"exp": exp, "lvl": lvl})
        with open(path, "w") as f:
            yaml.dump(conf, f, allow_unicode=True, sort_keys=False)
def main(prof: str = None) -> None:
    global koks, fire, exp, time, logo, smem, path, ftime, w, streak, sdata, lives, lvl, ldat, maxlive, lessonLength, conf, first, lern, normsing, normdub, hard
    time = datetime.datetime.strptime(datetime.datetime.now().strftime("%Y.%m.%d"), "%Y.%m.%d")
    ftime = datetime.datetime.now()
    first = False
    if prof == None:
        path = f"{Path.home()}/.config/duo.yaml"
    else:
        path = f"{Path.home()}/.config/duo{prof}.yaml"
    try:
        with open(path, "r") as f:
            conf = yaml.load(f, Loader=yaml.FullLoader)
    except FileNotFoundError:
        print("Creating new profile")
        sleep(2)
        first = True
        with open(path, "w+") as f:
            conf = {"logo": "Welcome to duolingo for blind", "smem": "Your streak gone","streak": {"count": 0, "data": time.strftime("%Y.%m.%d")}, "lvl": 0, "exp": 0, "hard": False, "lives": 5, "maxlives": 5, "ldat": ftime, "length": 5}
            yaml.dump(conf, f, allow_unicode=True, sort_keys=False)
    try:
        logo = conf["logo"]
    except:
        logo = "Welcome to duolingo"
    try:
        smem = conf["smem"]
    except:
        smem = "Your streak gone"
    streak = conf["streak"]["count"]
    sdata = datetime.datetime.strptime(conf["streak"]["data"], "%Y.%m.%d")
    lvl = conf["lvl"]
    exp = conf["exp"]
    lives = conf["lives"]
    ldat = conf["ldat"]
    maxlive = conf["maxlives"]
    lessonLength = conf["length"]
    hard = conf["hard"]
    try:
        lern = conf["lern"]
    except:
        lern = {"a": "⠁","b": "⠃","c": "⠉","d": "⠙","e": "⠑","f": "⠋","g": "⠛","h": "⠓","i": "⠊","j": "⠚","k": "⠅","l": "⠇","m": "⠍","n": "⠝","o": "⠕","p": "⠏","q": "⠟","r": "⠗","s": "⠎","t": "⠞","u": "⠥","v": "⠧","w": "⠺","x": "⠭","y": "⠽","z": "⠵","ą":"⠡","ć":"⠩","ę":"⠱","ł":"⠣","ń":"⠹","ó":"⠬","ś":"⠪","ż":"⠯","ź":"⠮","0":"⠼⠚","1":"⠼⠁","2":"⠼⠃","3":"⠼⠉","4":"⠼⠙","5":"⠼⠑","6":"⠼⠋","7":"⠼⠛","8":"⠼⠓","9":"⠼⠊","-": "⠒",".": "⠲","'": "⡀",",": "⠂"}
    try:
        normsing = conf["normal"]["single"]
    except:
        normsing = {"⠁":"a","⠃":"b","⠉":"c","⠙":"d","⠑":"e","⠋":"f","⠛":"g","⠓":"h","⠊":"i","⠚":"j","⠅":"k","⠇":"l","⠍":"m","⠝":"n","⠕":"o","⠏":"p","⠟":"q","⠗":"r","⠎":"s","⠞":"t","⠥":"u","⠧":"v","⠺":"w","⠭":"x","⠽":"y","⠵":"z","⠡":"ą","⠩":"ć","⠱":"ę","⠣":"ł","⠹":"ń","⠬":"ó","⠪":"ś","⠯":"ż","⠮":"ź","-": "⠒",".":"⠲","'": "⡀",",":"⠂"}
    try:
        normdub = conf["normal"]["dubles"]
    except:
        normdub = {"⠼⠚": "0","⠼⠁": "1", "⠼⠃": "2","⠼⠉": "3","⠼⠙": "4","⠼⠑": "5","⠼⠋": "6","⠼⠛": "7","⠼⠓": "8","⠼⠊": "9"}
    w = wonderwords.RandomWord()
    if not first:
        streakf(check = True)
    koks = False
    app = App(application_id="io.github.wilwe.duo")
    app.run()
    #menu()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-p", "--profile", help="set profile", nargs="*",default=None)
    args = parser.parse_args()
    if args.profile != None:
        args.profile = ' '.join(args.profile)
    main(args.profile)
